# A-Look-at-the-Design-of-Lua-
翻译A Look at the Design of Lua 文章
Lua是由罗马天主教大学（Pontifical Catholic University of 里约热内卢 de Janeiro）开发的一种脚本语言，现已成为全球电子游戏的主要脚本语言。它还广泛应用于机顶盒和电视等嵌入式设备，以及
Adobe Photoshop Lightroom图片处理和维基百科等其它应用程序。第一版发布于1993年。当前版本Lua5.3发布于2015年。

## 关键见解

- Lua与其它脚本语言的区别在于它的一系列特定目标：简单性，体积小，可移植，可嵌入。
- Lua的整个实现有25000行C代码；64位Linux的二进制文件有200k字节。
- 从一开始，Lua就被设计成与其它语言进行互操作。

虽然Lua主要是一种过程性语言，但它也适用于其它几种模式，包括面向对象编程、函数式编程和数据驱动编程。它还以JavaScript和JSON的风格提供了对数据描述的良好支持。
数据描述确实是我们创建Lua的主要动机之一，比XML和JavaScript出现早了几年。

我们在Lua设计中的座右铭一直是“机制而不是策略”。策略，我们指的是一种使用现有机制构建新抽象的系统方法。C语言中的封装提供了一个很好的策略示例。ISO C规范没有为模块或接口提供机制。然而，C程序员员利用现有的机制（例如文件包含和外部声明）来实现这些抽象。在C语言提供的这些基本机制之上，策略添加了一些规则（如“所有全局函数都应该在头文件中有一个原型”和“头文件不应该定义对象，只应该声明它们”）。许多程序员不知道这些规则（以及整个策略）不是C语言的一部分。

因此，在Lua设计中，我们通过只创建少数允许程序员自己实现这些功能的机制，取代了许多不同功能的添加。这句格言引出了一种感念上经济的设计。Lua为编程的每个主要方面提供了一种通用机制：数据表；抽象函数；
以及用于控制的协程。在这些构建块之上，程序员实现了其它一些特性，包括模块、对象和环境，并帮助对语言进行了最小的添加（如语法糖）。在此，我们讲着眼于这一理念在Lua设计中的作用。

## 设计目标

与其它脚本语言一样，Lua具有动态性、动态数据结构、垃圾收集和类似eval的功能。考虑一下Lua的特定目标：

简单。Lua的目标是只提供少数功能强大的机制来满足几种不同的需求，而不是无数种特定的 语言结构，每种结构都针对特定的需求量身定制。Lua参考手册很小，大约有100页，涵盖了Lua语言、它的标准库和C的API;

小尺寸。Lua的整个实现由25000行C代码组成；64位Linux的二进制文件有200k字节。对于可移植性（因为Lua在运行之前必须适应系统）和嵌入（因为它不应该使嵌入它的宿主应用程序膨胀）来说，体积小是很重要；

可移植性。Lua是用ISO C实现的，几乎可以在任何内存只有300k字节的系统中运行。Lua可以在所有主流系统中运行，也可以在大型机器上运行，可以在操作系统内核中运行（如NetBSD内核），也可以在“祼机”
上运行（如在ESP8266微控制器上运行的NodeMCU）;

嵌入性。Lua是自成立以来与其它语言交互，既可以扩展允许 Lua 代码调用其他语言编写的函数,也可以嵌入允许其他语言代码调用Lua 编写的函数. Lua因此实现不是作为一个独立的程序，而是一个C的API库。这个库导出一些函数，这些函数创建新的Lua State、将代码加载到某个状态、调用加载到某个状态的函数、访问某个状态中的全局变量，以及执行其他基本任务。独立的Lua解释器是一个在库之上编写的小型应用程序。

这些目标对我们的Lua设计产生了深刻的影响。可移植性限制了标准库提供的ISO C中可用的内容，包括日期和时间、文件和字符串操作，以及基本的数学函数。其它所有内用都必须有外部库提供。简单和小尺寸
限制了整个语言。这些是语言经济概念背后的目标。可嵌入性有更微妙的影响。为了提高可嵌入性，Lua倾向于在Lua-C API中自然表示的机制。例如，Lua试图避免或减少对新机制使用特殊语法，因为语法是
无法通过API访问的。另一方面，作为函数公开的机制自然会映射到API.

遵循“机制而不是策略”的格言，对简化和规模小有明显的影响。它还通过将复杂的概念分解成为更容易在API中表示的更简单的概念来影响可嵌入性。

Lua支持八种数据类型：nil、boolean、number、userdata、table、function和协程。前五项并不奇怪。最后三个元素赋予了Lua独特的风味，也是我们在此讨论的内容。然而，考虑到可嵌入性
在Lua设计中的重要性，我们首先简要介绍Lua与其宿主语言之间的接口。

## The Lua-C API

为了说明在Lua中嵌入的概念，考虑一个使用Lua库的简单C程序示例。以这个存储在文件中的小型Lua脚本为例

```lua 
pi = 4 * math.atan(1)
```

图1显示一个C程序，它运行这个脚本并打印pi的值。第一个任务是创建一个新的状态，并用标准库中的函数填充它（比如math.atan）.然后程序调用luaL_loadfile将给定的源文件加载（预编译）到这种状态。
如果没有错误，这个调用将产生一个Lua函数，然后由lua_pcall执行该函数。如果loadfile或pcall引发错误，它将产生一条错误信息，并打印到终端。否则，程序获取全局变量pi的值并打印它的值。

![图1 一个使用Lua库的C程序。](https://dl.acm.org/cms/attachment/0614157f-46e2-43c3-a57b-41646a7d2c31/f1.jpg)

                                                           图1 一个使用Lua库的C程序
这些API调用之间的数据交换是通过Lua状态下的隐式堆栈完成的。调用luaL _ loadfile将一个函数或一条错误消息推入堆栈。调用lua_ pcall从堆栈中弹出函数并调用它。对lua_ getglobal的调用会推入全局变量的值。调用lua_ tonnumber将堆栈上的lua值投射到一个double对象上。堆栈确保这些值在被C代码操作时对Lua保持可见，这样它们就不会被Lua的垃圾收集器收集。除了这个简单示例中使用的函数外，Lua-C API(简称“C API”)还提供了各种操作Lua值的函数，包括将C值(比如数字和字符串)推入堆栈、调用脚本定义的函数以及设置状态中的变量。

## 表

表”是Lua术语，指的是关联数组或“映射”。表只是条目的集合，条目是(键、值)对。

表是Lua中唯一的数据结构机制。现在，映射在大多数脚本语言和一些非脚本语言中都是可用的，但在Lua中映射是普遍存在的。实际上，Lua程序员不仅将表用于所有类型的数据结构(如记录、数组、列表、集合和稀疏矩阵)，而且还用于更高级别的构造(如模块、对象和环境)。

程序员使用表实现记录，表的索引是表示字段名的字符串。Lua支持带语法糖的记录，将字段引用(如t.x)转换为表索引操作t["x"]。

Lua提供了创建和初始化表的构造函数和表达式。构造函数{}创建一个空表。构造函数{x=10,y=20}创建一个有两个条目的表，一个将字符串“x”映射为整数10，另一个将“y”映射为20。程序员将此表视为字段为“x”和“y”的记录。

程序员使用索引为正整数的表实现数组。构造函数也支持这种用法。例如，表达式{10,20,30}创建了一个包含三个条目的表，将1映射到10,2映射到20,3映射到30。程序员将该表视为一个包含三个元素的数组。

数组在Lua的语义中没有特殊的地位;它们只是普通的表。然而，数组在编程中无处不在。因此，Lua中表的实现特别注意它们作为数组的使用。Lua中表的内部表示有两部分:一个数组和一个散列如果数组部分的大小为N，则所有键值在1到N之间的整数项都存储在数组部分;所有其他条目都存储在散列部分。数组部分中的键是隐式的，不需要存储。数组部分的大小N是动态计算的，每次表必须重新处理为2的最大次幂，这样数组部分的至少一半元素将被填充。一般访问(如t[i])首先检查i是否是范围[1,N]内的整数;这是最常见的情况，也是程序员所期望的速度。如果是，该操作获取数组中的值;否则，它访问散列。当访问记录字段(比如t.x)时，Lua核心知道键是一个字符串，因此跳过数组测试，直接进入散列。

这个实现的一个有趣的特性是它免费提供稀疏数组。例如，当程序员创建一个索引为5、100和3421的表时，Lua会自动将它们存储在散列部分，而不是创建一个包含数千个空槽的大数组。

*Lua为编程的每个主要方面提供了一种通用机制:数据表;抽象函数;以及用于控制的协程。*

Lua还使用表来实现弱引用。在使用垃圾收集的语言中，弱引用是对对象的引用，该对象不会阻止将其作为垃圾收集在Lua中，弱引用在弱表中实现。因此，弱表是不阻止其内容被收集的表。如果一个表项中的键或值被收集，则该表项被简单地从表中删除;我们将在后面讨论如何表示一个表是弱的。Lua中的弱表也包含临时表。

弱表似乎与“机制而不是策略”的格言相矛盾，因为弱引用是比弱表更基本的概念。弱表是一种策略，一种使用弱引用的特殊方式。然而，考虑到表在Lua中的角色，使用表来支持弱引用是很自然的，而无需引入另一个概念。




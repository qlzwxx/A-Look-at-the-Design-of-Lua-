# A-Look-at-the-Design-of-Lua-
翻译A Look at the Design of Lua 文章
Lua是由罗马天主教大学（Pontifical Catholic University of 里约热内卢 de Janeiro）开发的一种脚本语言，现已成为全球电子游戏的主要脚本语言。它还广泛应用于机顶盒和电视等嵌入式设备，以及
Adobe Photoshop Lightroom图片处理和维基百科等其它应用程序。第一版发布于1993年。当前版本Lua5.3发布于2015年。

## 关键见解

- Lua与其它脚本语言的区别在于它的一系列特定目标：简单性，体积小，可移植，可嵌入。
- Lua的整个实现有25000行C代码；64位Linux的二进制文件有200k字节。
- 从一开始，Lua就被设计成与其它语言进行互操作。

虽然Lua主要是一种过程性语言，但它也适用于其它几种模式，包括面向对象编程、函数式编程和数据驱动编程。它还以JavaScript和JSON的风格提供了对数据描述的良好支持。
数据描述确实是我们创建Lua的主要动机之一，比XML和JavaScript出现早了几年。

我们在Lua设计中的座右铭一直是“机制而不是策略”。策略，我们指的是一种使用现有机制构建新抽象的系统方法。C语言中的封装提供了一个很好的策略示例。ISO C规范没有为模块或接口提供机制。然而，C程序员员利用现有的机制（例如文件包含和外部声明）来实现这些抽象。在C语言提供的这些基本机制之上，策略添加了一些规则（如“所有全局函数都应该在头文件中有一个原型”和“头文件不应该定义对象，只应该声明它们”）。许多程序员不知道这些规则（以及整个策略）不是C语言的一部分。

因此，在Lua设计中，我们通过只创建少数允许程序员自己实现这些功能的机制，取代了许多不同功能的添加。这句格言引出了一种感念上经济的设计。Lua为编程的每个主要方面提供了一种通用机制：数据表；抽象函数；
以及用于控制的协程。在这些构建块之上，程序员实现了其它一些特性，包括模块、对象和环境，并帮助对语言进行了最小的添加（如语法糖）。在此，我们讲着眼于这一理念在Lua设计中的作用。

## 设计目标

与其它脚本语言一样，Lua具有动态性、动态数据结构、垃圾收集和类似eval的功能。考虑一下Lua的特定目标：

简单。Lua的目标是只提供少数功能强大的机制来满足几种不同的需求，而不是无数种特定的 语言结构，每种结构都针对特定的需求量身定制。Lua参考手册很小，大约有100页，涵盖了Lua语言、它的标准库和C的API;

小尺寸。Lua的整个实现由25000行C代码组成；64位Linux的二进制文件有200k字节。对于可移植性（因为Lua在运行之前必须适应系统）和嵌入（因为它不应该使嵌入它的宿主应用程序膨胀）来说，体积小是很重要；

可移植性。Lua是用ISO C实现的，几乎可以在任何内存只有300k字节的系统中运行。Lua可以在所有主流系统中运行，也可以在大型机器上运行，可以在操作系统内核中运行（如NetBSD内核），也可以在“祼机”
上运行（如在ESP8266微控制器上运行的NodeMCU）;

嵌入性。Lua是自成立以来与其它语言交互，既可以扩展允许 Lua 代码调用其他语言编写的函数,也可以嵌入允许其他语言代码调用Lua 编写的函数. Lua因此实现不是作为一个独立的程序，而是一个C的API库。这个库导出一些函数，这些函数创建新的Lua State、将代码加载到某个状态、调用加载到某个状态的函数、访问某个状态中的全局变量，以及执行其他基本任务。独立的Lua解释器是一个在库之上编写的小型应用程序。

这些目标对我们的Lua设计产生了深刻的影响。可移植性限制了标准库提供的ISO C中可用的内容，包括日期和时间、文件和字符串操作，以及基本的数学函数。其它所有内用都必须有外部库提供。简单和小尺寸
限制了整个语言。这些是语言经济概念背后的目标。可嵌入性有更微妙的影响。为了提高可嵌入性，Lua倾向于在Lua-C API中自然表示的机制。例如，Lua试图避免或减少对新机制使用特殊语法，因为语法是
无法通过API访问的。另一方面，作为函数公开的机制自然会映射到API.

遵循“机制而不是策略”的格言，对简化和规模小有明显的影响。它还通过将复杂的概念分解成为更容易在API中表示的更简单的概念来影响可嵌入性。

Lua支持八种数据类型：nil、boolean、number、userdata、table、function和协程。前五项并不奇怪。最后三个元素赋予了Lua独特的风味，也是我们在此讨论的内容。然而，考虑到可嵌入性
在Lua设计中的重要性，我们首先简要介绍Lua与其宿主语言之间的接口。

## The Lua-C API

为了说明在Lua中嵌入的概念，考虑一个使用Lua库的简单C程序示例。以这个存储在文件中的小型Lua脚本为例

```lua 
pi = 4 * math.atan(1)
```

图1显示一个C程序，它运行这个脚本并打印pi的值。第一个任务是创建一个新的状态，并用标准库中的函数填充它（比如math.atan）.然后程序调用luaL_loadfile将给定的源文件加载（预编译）到这种状态。
如果没有错误，这个调用将产生一个Lua函数，然后由lua_pcall执行该函数。如果loadfile或pcall引发错误，它将产生一条错误信息，并打印到终端。否则，程序获取全局变量pi的值并打印它的值。

![图1 一个使用Lua库的C程序。](https://dl.acm.org/cms/attachment/0614157f-46e2-43c3-a57b-41646a7d2c31/f1.jpg)

                                                           图1 一个使用Lua库的C程序
这些API调用之间的数据交换是通过Lua状态下的隐式栈完成的。调用luaL _ loadfile将一个函数或一条错误消息压入栈。调用lua_ pcall从栈中弹出函数并调用它。对lua_ getglobal的调用会压入全局变量的值。调用lua_ tonnumber将栈上的lua值投射到一个double对象上。栈确保这些值在被C代码操作时对Lua保持可见，这样它们就不会被Lua的垃圾收集器收集。除了这个简单示例中使用的函数外，Lua-C API(简称“C API”)还提供了各种操作Lua值的函数，包括将C值(比如数字和字符串)压入栈、调用脚本定义的函数以及设置状态中的变量。

## 表

表”是Lua术语，指的是关联数组或“映射”。表只是条目的集合，条目是(键、值)对。

表是Lua中唯一的数据结构机制。现在，映射在大多数脚本语言和一些非脚本语言中都是可用的，但在Lua中映射是普遍存在的。实际上，Lua程序员不仅将表用于所有类型的数据结构(如记录、数组、列表、集合和稀疏矩阵)，而且还用于更高级别的构造(如模块、对象和环境)。

程序员使用表实现记录，表的索引是表示字段名的字符串。Lua支持带语法糖的记录，将字段引用(如t.x)转换为表索引操作t["x"]。

Lua提供了创建和初始化表的构造函数和表达式。构造函数{}创建一个空表。构造函数{x=10,y=20}创建一个有两个条目的表，一个将字符串“x”映射为整数10，另一个将“y”映射为20。程序员将此表视为字段为“x”和“y”的记录。

程序员使用索引为正整数的表实现数组。构造函数也支持这种用法。例如，表达式{10,20,30}创建了一个包含三个条目的表，将1映射到10,2映射到20,3映射到30。程序员将该表视为一个包含三个元素的数组。

数组在Lua的语义中没有特殊的地位;它们只是普通的表。然而，数组在编程中无处不在。因此，Lua中表的实现特别注意它们作为数组的使用。Lua中表的内部表示有两部分:一个数组和一个散列如果数组部分的大小为N，则所有键值在1到N之间的整数项都存储在数组部分;所有其他条目都存储在散列部分。数组部分中的键是隐式的，不需要存储。数组部分的大小N是动态计算的，每次表必须重新处理为2的最大次幂，这样数组部分的至少一半元素将被填充。一般访问(如t[i])首先检查i是否是范围[1,N]内的整数;这是最常见的情况，也是程序员所期望的速度。如果是，该操作获取数组中的值;否则，它访问散列。当访问记录字段(比如t.x)时，Lua核心知道键是一个字符串，因此跳过数组测试，直接进入散列。

这个实现的一个有趣的特性是它免费提供稀疏数组。例如，当程序员创建一个索引为5、100和3421的表时，Lua会自动将它们存储在散列部分，而不是创建一个包含数千个空槽的大数组。

*Lua为编程的每个主要方面提供了一种通用机制:数据表;抽象函数;以及用于控制的协程。*

Lua还使用表来实现弱引用。在使用垃圾收集的语言中，弱引用是对对象的引用，该对象不会阻止将其作为垃圾收集在Lua中，弱引用在弱表中实现。因此，弱表是不阻止其内容被收集的表。如果一个表项中的键或值被收集，则该表项被简单地从表中删除;我们将在后面讨论如何表示一个表是弱的。Lua中的弱表也包含临时表。

弱表似乎与“机制而不是策略”的格言相矛盾，因为弱引用是比弱表更基本的概念。弱表是一种策略，一种使用弱引用的特殊方式。然而，考虑到表在Lua中的角色，使用表来支持弱引用是很自然的，而无需引入另一个概念。

## 函数

Lua支持具有词法作用域的一级匿名函数，非正式地称为闭包现在有几种非函数式语言(如Go、Swift、Python和JavaScript)提供了一流函数。然而，据我们所知，没有一种机制像Lua那样广泛地使用这种机制。

Lua中的所有函数都是匿名的。这在定义函数的标准语法中不是很清楚

```lua
function add (x, y)
    return x + y
end
```

然而，这种语法只是将匿名函数赋值给变量的语法糖

```lua
add = function (x, y)
    return x + y
end
```

大多数动态语言都提供了某种eval函数，用于对运行时生成的代码段进行计算。与eval不同，Lua提供了一个加载函数，给定一段源代码，该函数返回与该代码等价的函数。我们在C API中看到了load的一种变体，形式是luaL _ loadfile。考虑下面这段代码

```lua
local id = 0
function genid ()
    id = id + l
    return id
end
```

加载时，load函数返回一个匿名函数，等价于下面的代码

```lua
function ()
    local id = 0
    function genid ()
        id = id + 1
        return id
    end
end
```

因此，如果程序员加载存储在字符串中的Lua代码，然后调用生成的函数，则程序员将得到等效的eval。

我们使用术语“块”来表示提供给加载的一段代码(比如源文件)。块是Lua的编译单元。当程序员在交互模式下使用Lua时，Read-Eval-Print Loop (REPL)将每个输入行作为单独的块处理。

函数load以两种方式简化了Lua的语义:首先，与eval不同，load是纯粹的、完整的;它没有副作用，并且总是返回一个值，要么是一个函数，要么是一个错误消息;第二，它消除了“全局”代码和“函数”代码之间的区别，就像前面的代码块。在原始代码中，变量id出现在任何函数之外，Lua将其视为表示脚本的封闭匿名函数中的局部变量。通过词法作用域，id对genid函数是可见的，并在对该函数的连续调用之间保留其值。因此，id的工作方式类似于C语言中的静态变量或Java中的类变量。

## 探索表和函数

尽管表面上看起来很简单，但由于ittables和函数构成了Lua中其他一些机制的基础，包括模块、面向对象编程和异常处理。现在我们将讨论其中的一些内容，强调它们对Lua设计目标的贡献。

模块。在Lua中构造模块是使用一级函数和表作为其他机制基础的一个很好的例子。在运行时，Lua中的模块是一个用函数以及其他值(比如常量)填充的常规表。考虑这个Lua片段

```lua 
print(math.sin(math.pi/6)) --> 0.5
```

抽象地说，程序员将这段代码理解为从标准数学模块调用sin函数，使用同一模块中的常数pi。具体来说，该语言将数学视为一个变量(在Lua加载其标准库时创建)，其中包含对表的引用。该表有一个键值为“sin”的条目，其中包含正弦函数，还有一个键值为“pi”的条目。

静态地说，模块就是创建相应表的块。图2显示了在Lua中定义简单模块的标准习惯用法。代码在局部变量M中创建一个表，用一些函数填充该表，然后返回该表。回想一下，Lua将任何块作为封闭的匿名函数体加载;这就是应该如何阅读代码。变量M是该封闭函数的局部变量，最终语句从该函数返回。

![图2 Lua中的一个简单模块。](https://dl.acm.org/cms/attachment/56166380-c1be-4683-b586-faf7f119a981/f2.jpg)

                        图2 Lua中的一个简单模块。

一旦在mymodule文件中定义Lua，程序员可以将该模块与下面的代码一起使用

```lua 
local vec = require "mymodule" print(vec.norm(vec.new(10, 10)))--> 14.142135623731
```

其中，require是来自标准库的常规函数;当函数的单个参数是一个字面值字符串时，代码可以忽略调用中的括号。如果模块尚未加载，则要求搜索给定名称的适当源(例如在路径列表中查找文件)，然后加载并运行该代码，最后返回代码所返回的内容。在本例中，require返回由块创建的表M。

Lua利用表、一级函数和load来支持模块。唯一增加的语言是require函数。这种经济与像Lua这样的嵌入式语言特别相关。因为require是一个常规函数，它不能在调用者的作用域内创建局部变量。因此，在使用"mymodule"的例子中，程序员必须显式定义局部变量vec。然而，这种限制使程序员能够为模块指定一个本地名称。

一方面,构造模块在Lua中不是一样优雅的专用语言机制,与显式导入和导出列表和其他细化,如“Python进口机械”另一方面,这个构造有一个明确的语义,不需要进一步的解释。它还有一个廉价的实现。最后，也是非常重要的一点，它与C API的集成很容易:可以很容易地用C创建模块;用Lua和C中定义的函数创建混合模块;对于C代码调用模块内部的函数。API不需要额外的机制来完成这些任务;它只需要现有的Lua机制来操作表和函数。

**环境**。Lua中的局部变量遵循严格的词法范围原则。局部变量只能由在其作用域内按词法编写的代码访问。词法作用域意味着局部变量是少数几个不能跨C API的结构之一，因为C代码不能在Lua代码中词法上使用。

Lua中的程序可以由独立加载的多个块(比如多个模块)组成。词法作用域意味着模块不能为其他块创建局部变量。因此，由标准库创建的像math和require这样的变量应该被创建为全局变量。然而，在大型程序中使用全局变量很容易导致过于复杂的代码，使程序中显然不相关的部分纠缠在一起。为了避免这种冲突，Lua没有在语言中内置全局变量。相反，它提供了一种环境机制，默认情况下，它提供了等同于全局变量的环境。然而，正如我们在本文后面所展示的，环境允许其他可能性。

回想一下，Lua中的任何代码块都是像在匿名函数中那样编译的。环境为这种转换添加了两个简单的规则:首先，外围的匿名函数被编译，就像在名为_ ENV的局部变量的作用域中一样;第二，块中的任意自由变量id都被转换为_ ENV.id。例如，Lua加载块打印(v)，就像它是这样写的一样

```lua
local _ ENV = <<some given value>>
return function ()
    _ ENV.print( _ ENV.v)
end
```

默认情况下，load用一个称为全局环境的固定表初始化_ ENV。因此，默认情况下，所有块共享同一环境，从而产生全局变量的错觉;在刚才提到的数据块中，v和print都引用该表中的字段，因此表现为全局变量。但是，load和正在加载的代码都可以将_ ENV修改为任何其他值。ENV机制允许不同的脚本具有不同的环境，在不同的环境中调用函数，以及其他变体。

自由变量的翻译需要语义信息来确定变量是否自由。然而，翻译本身是纯粹的句法。特别是，_ ENV是一个常规变量，不需要编译器的特殊处理。程序员可以给_ ENV赋新值，也可以用该名称声明其他变量。以这个片段为例

```lua
do
    local _ ENV = {}
    ...
end
```

在do块中，所有的自由变量都指向新表_ ENV中的字段。在块之外，所有的自由变量都指向默认环境。

_ ENV的一个更典型的用法是用于编写模块。图3显示了如何使用环境重写图2中的简单模块。在第一行中，代码从math模块“导入”一个函数，环境仍然是默认的。在第二行中，代码将环境设置为表示模块的新表。然后代码将模块组件直接定义为自由变量;它只使用norm，而不是M.norm, Lua将其翻译为_ ENV.norm。代码以return _ ENV结束模块。

![图3一个使用环境的Lua模块。](https://dl.acm.org/cms/attachment/5b72d314-7981-4b84-918f-9600964209d0/f3.jpg)

图3一个使用环境的Lua模块。

这种编写模块的方法有两个好处:首先，所有外部函数和模块必须在一开始就显式导入;第二，模块不能错误地污染全局空间。

**面向对象编程**。Lua中对面向对象编程的支持遵循了我们在本文中看到的模式:它尝试在表和函数基础上构建，只向语言中添加了最基本的必要内容。

Lua使用了面向对象编程的两层方法。第一个是由Lua执行的，第二个是由程序员在第一个之上执行的。第一层是基于类的。对象和类都是表，关系“实例”是动态的。在Lua中表示C值的Userdata也可以扮演对象的角色。类称为元表。在这第一层中，类只能为标准操作符(如加、减和连接)定义方法。这些方法称为元方法。

图4说明了程序员如何使用这种基本机制在2D向量上执行运算。代码从一个表mt开始，它将是向量的元表。然后代码定义了一个函数newVector来创建2D向量。向量是带有两个字段x和y的表。标准函数setmetatable建立了一个新向量和mt之间的“实例”关系。接下来，代码定义了mt.___ add元方法来实现向量的加法运算符。然后，代码创建两个向量A和B，并将它们添加到一个新的向量c中。当Lua试图计算A+B时，它不知道如何添加表，因此检查A的元表中的__add项。如果找到了该条目，Lua将调用存储在那里的函数——将原始操作数A和B作为参数传递。

![图4一个元表的例子。](https://dl.acm.org/cms/attachment/d64e0701-fd18-49f8-943f-ae127e68f198/f4.jpg)

图4一个元表的例子。

索引操作符[]的元方法在Lua中提供了一种委托形式。每当Lua试图从表中检索一个缺席键的值时，就会调用这个名为__index的元方法。(对于userdata, Lua为所有键调用该元方法。)对于索引操作，Lua允许元方法是一个函数或一个表。当___index是一个表时，Lua将对原始表中没有的索引的所有访问委托给该表，如下面的代码片段所示

```lua 
Proto = {x = 0, y = 0}
obj = {x = 10}
mt = {___index = Proto}
setmetatable(obj, mt)
print(obj.x) > 10
print(obj.y) > 0
```

在第二个print调用中，Lua找不到obj中的键“y”，因此委托访问Proto。在第一个输出中，由于obj有一个字段"x"，访问没有委托。

有了表、函数和委托，我们就几乎拥有了基于原型的第二层所需的一切。在它中，程序员也用表或用户数据表示对象。每个对象都可以有一个原型，从中继承方法和字段。对象obj的原型是存储在obj元表__index字段中的对象。然后可以编写obj.foo(x)， Lua将通过委托从对象的原型中检索方法foo。

然而，如果我们就此打住，那么Lua中对面向对象编程的支持可能存在缺陷。在对象的原型中找到并调用该方法之后，该方法将无法访问原对象(即预期的接收者)。Lua通过语法糖解决了这个问题。Lua将“方法”定义翻译为

```lua 
function Proto:foo (x)
    ...
end
```

函数定义:

```lua
function Proto.foo (self, x)
    ...
end
```

同样，Lua将“方法”调用obj:foo(x)转换为obj.foo(obj,x)。当程序员定义一个“方法”时，使用冒号syntaxLua的函数会添加一个隐藏参数self。当程序员使用冒号语法调用“方法”时，Lua提供receiver作为self形参的参数。不需要向语言中添加类、对象或方法，只需添加语法糖即可。

图5说明了这些概念。首先，代码创建了一个原型表Account。然后，代码创建了一个表mt，用作Account实例的元表。然后，它向原型添加了三个方法:一个用于创建实例，一个用于存储，一个用于检索帐户余额。最后，它返回作为该模块结果的原型。

![图5 Lua中简单的基于原型的设计。](https://dl.acm.org/cms/attachment/056c660d-c3c3-4dcf-be5f-8cb44dbd7d5d/f5.jpg)

图5 Lua中简单的基于原型的设计。

假设模块位于文件Account中。在Lua中，下面几行代码执行

```lua
Account = require "Account"
acc = Account:new()
acc:deposit(1000)
print(acc:balance()) -->
1000
```

首先，代码需要模块，然后创建一个帐户;Acc将是一个空表，mt作为它的元表。去糖后，下一行是acc.deposit(acc,1000)。表acc没有存储字段，所以Lua委托访问元表的__index字段中的表。访问的结果就是Account.deposit功能。然后Lua调用该函数，将acc作为第一个参数(self)，将1000作为第二个参数(amount)。在函数内部，Lua将再次委派访问self。Bal到原型机因为acc还没有一个现场Bal。在随后对balance的调用中，Lua将在表acc中找到字段bal并使用该值。因此，不同的账户有不同的余额，但共享所有方法。



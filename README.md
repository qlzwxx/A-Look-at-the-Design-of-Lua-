# A-Look-at-the-Design-of-Lua-
翻译A Look at the Design of Lua 文章
Lua是由罗马天主教大学（Pontifical Catholic University of 里约热内卢 de Janeiro）开发的一种脚本语言，现已成为全球电子游戏的主要脚本语言。它还广泛应用于机顶盒和电视等嵌入式设备，以及
Adobe Photoshop Lightroom图片处理和维基百科等其它应用程序。第一版发布于1993年。当前版本Lua5.3发布于2015年。

## 关键见解

- Lua与其它脚本语言的区别在于它的一系列特定目标：简单性，体积小，可移植，可嵌入。
- Lua的整个实现有25000行C代码；64位Linux的二进制文件有200k字节。
- 从一开始，Lua就被设计成与其它语言进行互操作。

虽然Lua主要是一种过程性语言，但它也适用于其它几种模式，包括面向对象编程、函数式编程和数据驱动编程。它还以JavaScript和JSON的风格提供了对数据描述的良好支持。
数据描述确实是我们创建Lua的主要动机之一，比XML和JavaScript出现早了几年。

我们在Lua设计中的座右铭一直是“机制而不是策略”。策略，我们指的是一种使用现有机制构建新抽象的系统方法。C语言中的封装提供了一个很好的策略示例。ISO C规范没有为模块或接口提供机制。然而，C程序员员利用现有的机制（例如文件包含和外部声明）来实现这些抽象。在C语言提供的这些基本机制之上，策略添加了一些规则（如“所有全局函数都应该在头文件中有一个原型”和“头文件不应该定义对象，只应该声明它们”）。许多程序员不知道这些规则（以及整个策略）不是C语言的一部分。

因此，在Lua设计中，我们通过只创建少数允许程序员自己实现这些功能的机制，取代了许多不同功能的添加。这句格言引出了一种感念上经济的设计。Lua为编程的每个主要方面提供了一种通用机制：数据表；抽象函数；
以及用于控制的协程。在这些构建块之上，程序员实现了其它一些特性，包括模块、对象和环境，并帮助对语言进行了最小的添加（如语法糖）。在此，我们讲着眼于这一理念在Lua设计中的作用。

## 设计目标

与其它脚本语言一样，Lua具有动态性、动态数据结构、垃圾收集和类似eval的功能。考虑一下Lua的特定目标：

简单。Lua的目标是只提供少数功能强大的机制来满足几种不同的需求，而不是无数种特定的 语言结构，每种结构都针对特定的需求量身定制。Lua参考手册很小，大约有100页，涵盖了Lua语言、它的标准库和C的API;

小尺寸。Lua的整个实现由25000行C代码组成；64位Linux的二进制文件有200k字节。对于可移植性（因为Lua在运行之前必须适应系统）和嵌入（因为它不应该使嵌入它的宿主应用程序膨胀）来说，体积小是很重要；

可移植性。Lua是用ISO C实现的，几乎可以在任何内存只有300k字节的系统中运行。Lua可以在所有主流系统中运行，也可以在大型机器上运行，可以在操作系统内核中运行（如NetBSD内核），也可以在“祼机”
上运行（如在ESP8266微控制器上运行的NodeMCU）;

嵌入性。Lua是自成立以来与其它语言交互，既可以扩展允许 Lua 代码调用其他语言编写的函数,也可以嵌入允许其他语言代码调用Lua 编写的函数. Lua因此实现不是作为一个独立的程序，而是一个C的API库。这个库导出一些函数，这些函数创建新的Lua State、将代码加载到某个状态、调用加载到某个状态的函数、访问某个状态中的全局变量，以及执行其他基本任务。独立的Lua解释器是一个在库之上编写的小型应用程序。

这些目标对我们的Lua设计产生了深刻的影响。可移植性限制了标准库提供的ISO C中可用的内容，包括日期和时间、文件和字符串操作，以及基本的数学函数。其它所有内用都必须有外部库提供。简单和小尺寸
限制了整个语言。这些是语言经济概念背后的目标。可嵌入性有更微妙的影响。为了提高可嵌入性，Lua倾向于在Lua-C API中自然表示的机制。例如，Lua试图避免或减少对新机制使用特殊语法，因为语法是
无法通过API访问的。另一方面，作为函数公开的机制自然会映射到API.

遵循“机制而不是策略”的格言，对简化和规模小有明显的影响。它还通过将复杂的概念分解成为更容易在API中表示的更简单的概念来影响可嵌入性。

Lua支持八种数据类型：nil、boolean、number、userdata、table、function和协程。前五项并不奇怪。最后三个元素赋予了Lua独特的风味，也是我们在此讨论的内容。然而，考虑到可嵌入性
在Lua设计中的重要性，我们首先简要介绍Lua与其宿主语言之间的接口。

## The Lua-C API

为了说明在Lua中嵌入的概念，考虑一个使用Lua库的简单C程序示例。以这个存储在文件中的小型Lua脚本为例

```lua 
pi = 4 * math.atan(1)
```

图1显示一个C程序，它运行这个脚本并打印pi的值。第一个任务是创建一个新的状态，并用标准库中的函数填充它（比如math.atan）.然后程序调用luaL_loadfile将给定的源文件加载（预编译）到这种状态。
如果没有错误，这个调用将产生一个Lua函数，然后由lua_pcall执行该函数。如果loadfile或pcall引发错误，它将产生一条错误信息，并打印到终端。否则，程序获取全局变量pi的值并打印它的值。

![图1 一个使用Lua库的C程序。](https://dl.acm.org/cms/attachment/0614157f-46e2-43c3-a57b-41646a7d2c31/f1.jpg)

                                                           图1 一个使用Lua库的C程序
这些API调用之间的数据交换是通过Lua状态下的隐式堆栈完成的。调用luaL _ loadfile将一个函数或一条错误消息推入堆栈。调用lua_ pcall从堆栈中弹出函数并调用它。对lua_ getglobal的调用会推入全局变量的值。调用lua_ tonnumber将堆栈上的lua值投射到一个double对象上。堆栈确保这些值在被C代码操作时对Lua保持可见，这样它们就不会被Lua的垃圾收集器收集。除了这个简单示例中使用的函数外，Lua-C API(简称“C API”)还提供了各种操作Lua值的函数，包括将C值(比如数字和字符串)推入堆栈、调用脚本定义的函数以及设置状态中的变量。

## 表

表”是Lua术语，指的是关联数组或“映射”。表只是条目的集合，条目是(键、值)对。

表是Lua中唯一的数据结构机制。现在，映射在大多数脚本语言和一些非脚本语言中都是可用的，但在Lua中映射是普遍存在的。实际上，Lua程序员不仅将表用于所有类型的数据结构(如记录、数组、列表、集合和稀疏矩阵)，而且还用于更高级别的构造(如模块、对象和环境)。

程序员使用表实现记录，表的索引是表示字段名的字符串。Lua支持带语法糖的记录，将字段引用(如t.x)转换为表索引操作t["x"]。

Lua提供了创建和初始化表的构造函数和表达式。构造函数{}创建一个空表。构造函数{x=10,y=20}创建一个有两个条目的表，一个将字符串“x”映射为整数10，另一个将“y”映射为20。程序员将此表视为字段为“x”和“y”的记录。

程序员使用索引为正整数的表实现数组。构造函数也支持这种用法。例如，表达式{10,20,30}创建了一个包含三个条目的表，将1映射到10,2映射到20,3映射到30。程序员将该表视为一个包含三个元素的数组。

数组在Lua的语义中没有特殊的地位;它们只是普通的表。然而，数组在编程中无处不在。因此，Lua中表的实现特别注意它们作为数组的使用。Lua中表的内部表示有两部分:一个数组和一个散列如果数组部分的大小为N，则所有键值在1到N之间的整数项都存储在数组部分;所有其他条目都存储在散列部分。数组部分中的键是隐式的，不需要存储。数组部分的大小N是动态计算的，每次表必须重新处理为2的最大次幂，这样数组部分的至少一半元素将被填充。一般访问(如t[i])首先检查i是否是范围[1,N]内的整数;这是最常见的情况，也是程序员所期望的速度。如果是，该操作获取数组中的值;否则，它访问散列。当访问记录字段(比如t.x)时，Lua核心知道键是一个字符串，因此跳过数组测试，直接进入散列。

这个实现的一个有趣的特性是它免费提供稀疏数组。例如，当程序员创建一个索引为5、100和3421的表时，Lua会自动将它们存储在散列部分，而不是创建一个包含数千个空槽的大数组。

*Lua为编程的每个主要方面提供了一种通用机制:数据表;抽象函数;以及用于控制的协程。*

Lua还使用表来实现弱引用。在使用垃圾收集的语言中，弱引用是对对象的引用，该对象不会阻止将其作为垃圾收集在Lua中，弱引用在弱表中实现。因此，弱表是不阻止其内容被收集的表。如果一个表项中的键或值被收集，则该表项被简单地从表中删除;我们将在后面讨论如何表示一个表是弱的。Lua中的弱表也包含临时表。

弱表似乎与“机制而不是策略”的格言相矛盾，因为弱引用是比弱表更基本的概念。弱表是一种策略，一种使用弱引用的特殊方式。然而，考虑到表在Lua中的角色，使用表来支持弱引用是很自然的，而无需引入另一个概念。

## 函数

Lua支持具有词法作用域的一级匿名函数，非正式地称为闭包现在有几种非函数式语言(如Go、Swift、Python和JavaScript)提供了一流函数。然而，据我们所知，没有一种机制像Lua那样广泛地使用这种机制。

Lua中的所有函数都是匿名的。这在定义函数的标准语法中不是很清楚

```lua
function add (x, y)
    return x + y
end
```

然而，这种语法只是将匿名函数赋值给变量的语法糖

```lua
add = function (x, y)
    return x + y
end
```

大多数动态语言都提供了某种eval函数，用于对运行时生成的代码段进行计算。与eval不同，Lua提供了一个加载函数，给定一段源代码，该函数返回与该代码等价的函数。我们在C API中看到了load的一种变体，形式是luaL _ loadfile。考虑下面这段代码

```lua
local id = 0
function genid ()
    id = id + l
    return id
end
```

加载时，load函数返回一个匿名函数，等价于下面的代码

```lua
function ()
    local id = 0
    function genid ()
        id = id + 1
        return id
    end
end
```

因此，如果程序员加载存储在字符串中的Lua代码，然后调用生成的函数，则程序员将得到等效的eval。

我们使用术语“块”来表示提供给加载的一段代码(比如源文件)。块是Lua的编译单元。当程序员在交互模式下使用Lua时，Read-Eval-Print Loop (REPL)将每个输入行作为单独的块处理。

函数load以两种方式简化了Lua的语义:首先，与eval不同，load是纯粹的、完整的;它没有副作用，并且总是返回一个值，要么是一个函数，要么是一个错误消息;第二，它消除了“全局”代码和“函数”代码之间的区别，就像前面的代码块。在原始代码中，变量id出现在任何函数之外，Lua将其视为表示脚本的封闭匿名函数中的局部变量。通过词法作用域，id对genid函数是可见的，并在对该函数的连续调用之间保留其值。因此，id的工作方式类似于C语言中的静态变量或Java中的类变量。

## 探索表和函数

尽管表面上看起来很简单，但由于ittables和函数构成了Lua中其他一些机制的基础，包括模块、面向对象编程和异常处理。现在我们将讨论其中的一些内容，强调它们对Lua设计目标的贡献。

模块。在Lua中构造模块是使用一级函数和表作为其他机制基础的一个很好的例子。在运行时，Lua中的模块是一个用函数以及其他值(比如常量)填充的常规表。考虑这个Lua片段

```lua 
print(math.sin(math.pi/6)) --> 0.5
```

抽象地说，程序员将这段代码理解为从标准数学模块调用sin函数，使用同一模块中的常数pi。具体来说，该语言将数学视为一个变量(在Lua加载其标准库时创建)，其中包含对表的引用。该表有一个键值为“sin”的条目，其中包含正弦函数，还有一个键值为“pi”的条目。

静态地说，模块就是创建相应表的块。图2显示了在Lua中定义简单模块的标准习惯用法。代码在局部变量M中创建一个表，用一些函数填充该表，然后返回该表。回想一下，Lua将任何块作为封闭的匿名函数体加载;这就是应该如何阅读代码。变量M是该封闭函数的局部变量，最终语句从该函数返回。

![图2 Lua中的一个简单模块。](https://dl.acm.org/cms/attachment/56166380-c1be-4683-b586-faf7f119a981/f2.jpg)

                        图2 Lua中的一个简单模块。

一旦在mymodule文件中定义Lua，程序员可以将该模块与下面的代码一起使用

```lua 
local vec = require "mymodule" print(vec.norm(vec.new(10, 10)))--> 14.142135623731
```

其中，require是来自标准库的常规函数;当函数的单个参数是一个字面值字符串时，代码可以忽略调用中的括号。如果模块尚未加载，则要求搜索给定名称的适当源(例如在路径列表中查找文件)，然后加载并运行该代码，最后返回代码所返回的内容。在本例中，require返回由块创建的表M。

Lua利用表、一级函数和load来支持模块。唯一增加的语言是require函数。这种经济与像Lua这样的嵌入式语言特别相关。因为require是一个常规函数，它不能在调用者的作用域内创建局部变量。因此，在使用"mymodule"的例子中，程序员必须显式定义局部变量vec。然而，这种限制使程序员能够为模块指定一个本地名称。

一方面,构造模块在Lua中不是一样优雅的专用语言机制,与显式导入和导出列表和其他细化,如“Python进口机械”另一方面,这个构造有一个明确的语义,不需要进一步的解释。它还有一个廉价的实现。最后，也是非常重要的一点，它与C API的集成很容易:可以很容易地用C创建模块;用Lua和C中定义的函数创建混合模块;对于C代码调用模块内部的函数。API不需要额外的机制来完成这些任务;它只需要现有的Lua机制来操作表和函数。

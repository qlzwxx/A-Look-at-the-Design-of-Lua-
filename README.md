# A-Look-at-the-Design-of-Lua-
翻译A Look at the Design of Lua 文章
Lua是由罗马天主教大学（Pontifical Catholic University of 里约热内卢 de Janeiro）开发的一种脚本语言，现已成为全球电子游戏的主要脚本语言。它还广泛应用于机顶盒和电视等嵌入式设备，以及
Adobe Photoshop Lightroom图片处理和维基百科等其它应用程序。第一版发布于1993年。当前版本Lua5.3发布于2015年。

## 关键见解

- Lua与其它脚本语言的区别在于它的一系列特定目标：简单性，体积小，可移植，可嵌入。
- Lua的整个实现有25000行C代码；64位Linux的二进制文件有200k字节。
- 从一开始，Lua就被设计成与其它语言进行互操作。

虽然Lua主要是一种过程性语言，但它也适用于其它几种模式，包括面向对象编程、函数式编程和数据驱动编程。它还以JavaScript和JSON的风格提供了对数据描述的良好支持。
数据描述确实是我们创建Lua的主要动机之一，比XML和JavaScript出现早了几年。

我们在Lua设计中的座右铭一直是“机制而不是策略”。策略，我们指的是一种使用现有机制构建新抽象的系统方法。C语言中的封装提供了一个很好的策略示例。ISO C规范没有为模块或接口提供机制。然而，C程序员员利用现有的机制（例如文件包含和外部声明）来实现这些抽象。在C语言提供的这些基本机制之上，策略添加了一些规则（如“所有全局函数都应该在头文件中有一个原型”和“头文件不应该定义对象，只应该声明它们”）。许多程序员不知道这些规则（以及整个策略）不是C语言的一部分。

因此，在Lua设计中，我们通过只创建少数允许程序员自己实现这些功能的机制，取代了许多不同功能的添加。这句格言引出了一种感念上经济的设计。Lua为编程的每个主要方面提供了一种通用机制：数据表；抽象函数；
以及用于控制的协程。在这些构建块之上，程序员实现了其它一些特性，包括模块、对象和环境，并帮助对语言进行了最小的添加（如语法糖）。在此，我们讲着眼于这一理念在Lua设计中的作用。

## 设计目标

与其它脚本语言一样，Lua具有动态性、动态数据结构、垃圾收集和类似eval的功能。考虑一下Lua的特定目标：

简单。Lua的目标是只提供少数功能强大的机制来满足几种不同的需求，而不是无数种特定的 语言结构，每种结构都针对特定的需求量身定制。Lua参考手册很小，大约有100页，涵盖了Lua语言、它的标准库和C的API;

小尺寸。Lua的整个实现由25000行C代码组成；64位Linux的二进制文件有200k字节。对于可移植性（因为Lua在运行之前必须适应系统）和嵌入（因为它不应该使嵌入它的宿主应用程序膨胀）来说，体积小是很重要；

可移植性。Lua是用ISO C实现的，几乎可以在任何内存只有300k字节的系统中运行。Lua可以在所有主流系统中运行，也可以在大型机器上运行，可以在操作系统内核中运行（如NetBSD内核），也可以在“祼机”
上运行（如在ESP8266微控制器上运行的NodeMCU）;

嵌入性。Lua是自成立以来与其它语言交互，既可以扩展允许 Lua 代码调用其他语言编写的函数,也可以嵌入允许其他语言代码调用Lua 编写的函数. Lua因此实现不是作为一个独立的程序，而是一个C的API库。这个库导出一些函数，这些函数创建新的Lua State、将代码加载到某个状态、调用加载到某个状态的函数、访问某个状态中的全局变量，以及执行其他基本任务。独立的Lua解释器是一个在库之上编写的小型应用程序。

这些目标对我们的Lua设计产生了深刻的影响。可移植性限制了标准库提供的ISO C中可用的内容，包括日期和时间、文件和字符串操作，以及基本的数学函数。其它所有内用都必须有外部库提供。简单和小尺寸
限制了整个语言。这些是语言经济概念背后的目标。可嵌入性有更微妙的影响。为了提高可嵌入性，Lua倾向于在Lua-C API中自然表示的机制。例如，Lua试图避免或减少对新机制使用特殊语法，因为语法是
无法通过API访问的。另一方面，作为函数公开的机制自然会映射到API.

遵循“机制而不是策略”的格言，对简化和规模小有明显的影响。它还通过将复杂的概念分解成为更容易在API中表示的更简单的概念来影响可嵌入性。

Lua支持八种数据类型：nil、boolean、number、userdata、table、function和协程。前五项并不奇怪。最后三个元素赋予了Lua独特的风味，也是我们在此讨论的内容。然而，考虑到可嵌入性
在Lua设计中的重要性，我们首先简要介绍Lua与其宿主语言之间的接口。

## The Lua-C API

为了说明在Lua中嵌入的概念，考虑一个使用Lua库的简单C程序示例。以这个存储在文件中的小型Lua脚本为例

```lua 
pi = 4 * math.atan(1)
```

图1显示一个C程序，它运行这个脚本并打印pi的值。第一个任务是创建一个新的状态，并用标准库中的函数填充它（比如math.atan）.然后程序调用luaL_loadfile将给定的源文件加载（预编译）到这种状态。
如果没有错误，这个调用将产生一个Lua函数，然后由lua_pcall执行该函数。如果loadfile或pcall引发错误，它将产生一条错误信息，并打印到终端。否则，程序获取全局变量pi的值并打印它的值。

![图1 一个使用Lua库的C程序。](https://dl.acm.org/cms/attachment/0614157f-46e2-43c3-a57b-41646a7d2c31/f1.jpg)

                                                           图1 一个使用Lua库的C程序
这些API调用之间的数据交换是通过Lua状态下的隐式栈完成的。调用luaL _ loadfile将一个函数或一条错误消息压入栈。调用lua_ pcall从栈中弹出函数并调用它。对lua_ getglobal的调用会压入全局变量的值。调用lua_ tonnumber将栈上的lua值投射到一个double对象上。栈确保这些值在被C代码操作时对Lua保持可见，这样它们就不会被Lua的垃圾收集器收集。除了这个简单示例中使用的函数外，Lua-C API(简称“C API”)还提供了各种操作Lua值的函数，包括将C值(比如数字和字符串)压入栈、调用脚本定义的函数以及设置状态中的变量。

## 表

表”是Lua术语，指的是关联数组或“映射”。表只是条目的集合，条目是(键、值)对。

表是Lua中唯一的数据结构机制。现在，映射在大多数脚本语言和一些非脚本语言中都是可用的，但在Lua中映射是普遍存在的。实际上，Lua程序员不仅将表用于所有类型的数据结构(如记录、数组、列表、集合和稀疏矩阵)，而且还用于更高级别的构造(如模块、对象和环境)。

程序员使用表实现记录，表的索引是表示字段名的字符串。Lua支持带语法糖的记录，将字段引用(如t.x)转换为表索引操作t["x"]。

Lua提供了创建和初始化表的构造函数和表达式。构造函数{}创建一个空表。构造函数{x=10,y=20}创建一个有两个条目的表，一个将字符串“x”映射为整数10，另一个将“y”映射为20。程序员将此表视为字段为“x”和“y”的记录。

程序员使用索引为正整数的表实现数组。构造函数也支持这种用法。例如，表达式{10,20,30}创建了一个包含三个条目的表，将1映射到10,2映射到20,3映射到30。程序员将该表视为一个包含三个元素的数组。

数组在Lua的语义中没有特殊的地位;它们只是普通的表。然而，数组在编程中无处不在。因此，Lua中表的实现特别注意它们作为数组的使用。Lua中表的内部表示有两部分:一个数组和一个散列如果数组部分的大小为N，则所有键值在1到N之间的整数项都存储在数组部分;所有其他条目都存储在散列部分。数组部分中的键是隐式的，不需要存储。数组部分的大小N是动态计算的，每次表必须重新处理为2的最大次幂，这样数组部分的至少一半元素将被填充。一般访问(如t[i])首先检查i是否是范围[1,N]内的整数;这是最常见的情况，也是程序员所期望的速度。如果是，该操作获取数组中的值;否则，它访问散列。当访问记录字段(比如t.x)时，Lua核心知道键是一个字符串，因此跳过数组测试，直接进入散列。

这个实现的一个有趣的特性是它免费提供稀疏数组。例如，当程序员创建一个索引为5、100和3421的表时，Lua会自动将它们存储在散列部分，而不是创建一个包含数千个空槽的大数组。

*Lua为编程的每个主要方面提供了一种通用机制:数据表;抽象函数;以及用于控制的协程。*

Lua还使用表来实现弱引用。在使用垃圾收集的语言中，弱引用是对对象的引用，该对象不会阻止将其作为垃圾收集在Lua中，弱引用在弱表中实现。因此，弱表是不阻止其内容被收集的表。如果一个表项中的键或值被收集，则该表项被简单地从表中删除;我们将在后面讨论如何表示一个表是弱的。Lua中的弱表也包含临时表。

弱表似乎与“机制而不是策略”的格言相矛盾，因为弱引用是比弱表更基本的概念。弱表是一种策略，一种使用弱引用的特殊方式。然而，考虑到表在Lua中的角色，使用表来支持弱引用是很自然的，而无需引入另一个概念。

## 函数

Lua支持具有词法作用域的一级匿名函数，非正式地称为闭包现在有几种非函数式语言(如Go、Swift、Python和JavaScript)提供了一流函数。然而，据我们所知，没有一种机制像Lua那样广泛地使用这种机制。

Lua中的所有函数都是匿名的。这在定义函数的标准语法中不是很清楚

```lua
function add (x, y)
    return x + y
end
```

然而，这种语法只是将匿名函数赋值给变量的语法糖

```lua
add = function (x, y)
    return x + y
end
```

大多数动态语言都提供了某种eval函数，用于对运行时生成的代码段进行计算。与eval不同，Lua提供了一个加载函数，给定一段源代码，该函数返回与该代码等价的函数。我们在C API中看到了load的一种变体，形式是luaL _ loadfile。考虑下面这段代码

```lua
local id = 0
function genid ()
    id = id + l
    return id
end
```

加载时，load函数返回一个匿名函数，等价于下面的代码

```lua
function ()
    local id = 0
    function genid ()
        id = id + 1
        return id
    end
end
```

因此，如果程序员加载存储在字符串中的Lua代码，然后调用生成的函数，则程序员将得到等效的eval。

我们使用术语“块”来表示提供给加载的一段代码(比如源文件)。块是Lua的编译单元。当程序员在交互模式下使用Lua时，Read-Eval-Print Loop (REPL)将每个输入行作为单独的块处理。

函数load以两种方式简化了Lua的语义:首先，与eval不同，load是纯粹的、完整的;它没有副作用，并且总是返回一个值，要么是一个函数，要么是一个错误消息;第二，它消除了“全局”代码和“函数”代码之间的区别，就像前面的代码块。在原始代码中，变量id出现在任何函数之外，Lua将其视为表示脚本的封闭匿名函数中的局部变量。通过词法作用域，id对genid函数是可见的，并在对该函数的连续调用之间保留其值。因此，id的工作方式类似于C语言中的静态变量或Java中的类变量。

## 探索表和函数

尽管表面上看起来很简单，但由于ittables和函数构成了Lua中其他一些机制的基础，包括模块、面向对象编程和异常处理。现在我们将讨论其中的一些内容，强调它们对Lua设计目标的贡献。

模块。在Lua中构造模块是使用一级函数和表作为其他机制基础的一个很好的例子。在运行时，Lua中的模块是一个用函数以及其他值(比如常量)填充的常规表。考虑这个Lua片段

```lua 
print(math.sin(math.pi/6)) --> 0.5
```

抽象地说，程序员将这段代码理解为从标准数学模块调用sin函数，使用同一模块中的常数pi。具体来说，该语言将数学视为一个变量(在Lua加载其标准库时创建)，其中包含对表的引用。该表有一个键值为“sin”的条目，其中包含正弦函数，还有一个键值为“pi”的条目。

静态地说，模块就是创建相应表的块。图2显示了在Lua中定义简单模块的标准习惯用法。代码在局部变量M中创建一个表，用一些函数填充该表，然后返回该表。回想一下，Lua将任何块作为封闭的匿名函数体加载;这就是应该如何阅读代码。变量M是该封闭函数的局部变量，最终语句从该函数返回。

![图2 Lua中的一个简单模块。](https://dl.acm.org/cms/attachment/56166380-c1be-4683-b586-faf7f119a981/f2.jpg)

                        图2 Lua中的一个简单模块。

一旦在mymodule文件中定义Lua，程序员可以将该模块与下面的代码一起使用

```lua 
local vec = require "mymodule" print(vec.norm(vec.new(10, 10)))--> 14.142135623731
```

其中，require是来自标准库的常规函数;当函数的单个参数是一个字面值字符串时，代码可以忽略调用中的括号。如果模块尚未加载，则要求搜索给定名称的适当源(例如在路径列表中查找文件)，然后加载并运行该代码，最后返回代码所返回的内容。在本例中，require返回由块创建的表M。

Lua利用表、一级函数和load来支持模块。唯一增加的语言是require函数。这种经济与像Lua这样的嵌入式语言特别相关。因为require是一个常规函数，它不能在调用者的作用域内创建局部变量。因此，在使用"mymodule"的例子中，程序员必须显式定义局部变量vec。然而，这种限制使程序员能够为模块指定一个本地名称。

一方面,构造模块在Lua中不是一样优雅的专用语言机制,与显式导入和导出列表和其他细化,如“Python进口机械”另一方面,这个构造有一个明确的语义,不需要进一步的解释。它还有一个廉价的实现。最后，也是非常重要的一点，它与C API的集成很容易:可以很容易地用C创建模块;用Lua和C中定义的函数创建混合模块;对于C代码调用模块内部的函数。API不需要额外的机制来完成这些任务;它只需要现有的Lua机制来操作表和函数。

**环境**。Lua中的局部变量遵循严格的词法范围原则。局部变量只能由在其作用域内按词法编写的代码访问。词法作用域意味着局部变量是少数几个不能跨C API的结构之一，因为C代码不能在Lua代码中词法上使用。

Lua中的程序可以由独立加载的多个块(比如多个模块)组成。词法作用域意味着模块不能为其他块创建局部变量。因此，由标准库创建的像math和require这样的变量应该被创建为全局变量。然而，在大型程序中使用全局变量很容易导致过于复杂的代码，使程序中显然不相关的部分纠缠在一起。为了避免这种冲突，Lua没有在语言中内置全局变量。相反，它提供了一种环境机制，默认情况下，它提供了等同于全局变量的环境。然而，正如我们在本文后面所展示的，环境允许其他可能性。

回想一下，Lua中的任何代码块都是像在匿名函数中那样编译的。环境为这种转换添加了两个简单的规则:首先，外围的匿名函数被编译，就像在名为_ ENV的局部变量的作用域中一样;第二，块中的任意自由变量id都被转换为_ ENV.id。例如，Lua加载块打印(v)，就像它是这样写的一样

```lua
local _ ENV = <<some given value>>
return function ()
    _ ENV.print( _ ENV.v)
end
```

默认情况下，load用一个称为全局环境的固定表初始化_ ENV。因此，默认情况下，所有块共享同一环境，从而产生全局变量的错觉;在刚才提到的数据块中，v和print都引用该表中的字段，因此表现为全局变量。但是，load和正在加载的代码都可以将_ ENV修改为任何其他值。ENV机制允许不同的脚本具有不同的环境，在不同的环境中调用函数，以及其他变体。

自由变量的翻译需要语义信息来确定变量是否自由。然而，翻译本身是纯粹的句法。特别是，_ ENV是一个常规变量，不需要编译器的特殊处理。程序员可以给_ ENV赋新值，也可以用该名称声明其他变量。以这个片段为例

```lua
do
    local _ ENV = {}
    ...
end
```

在do块中，所有的自由变量都指向新表_ ENV中的字段。在块之外，所有的自由变量都指向默认环境。

_ ENV的一个更典型的用法是用于编写模块。图3显示了如何使用环境重写图2中的简单模块。在第一行中，代码从math模块“导入”一个函数，环境仍然是默认的。在第二行中，代码将环境设置为表示模块的新表。然后代码将模块组件直接定义为自由变量;它只使用norm，而不是M.norm, Lua将其翻译为_ ENV.norm。代码以return _ ENV结束模块。

![图3一个使用环境的Lua模块。](https://dl.acm.org/cms/attachment/5b72d314-7981-4b84-918f-9600964209d0/f3.jpg)

图3一个使用环境的Lua模块。

这种编写模块的方法有两个好处:首先，所有外部函数和模块必须在一开始就显式导入;第二，模块不能错误地污染全局空间。

**面向对象编程**。Lua中对面向对象编程的支持遵循了我们在本文中看到的模式:它尝试在表和函数基础上构建，只向语言中添加了最基本的必要内容。

Lua使用了面向对象编程的两层方法。第一个是由Lua执行的，第二个是由程序员在第一个之上执行的。第一层是基于类的。对象和类都是表，关系“实例”是动态的。在Lua中表示C值的Userdata也可以扮演对象的角色。类称为元表。在这第一层中，类只能为标准操作符(如加、减和连接)定义方法。这些方法称为元方法。

图4说明了程序员如何使用这种基本机制在2D向量上执行运算。代码从一个表mt开始，它将是向量的元表。然后代码定义了一个函数newVector来创建2D向量。向量是带有两个字段x和y的表。标准函数setmetatable建立了一个新向量和mt之间的“实例”关系。接下来，代码定义了mt.___ add元方法来实现向量的加法运算符。然后，代码创建两个向量A和B，并将它们添加到一个新的向量c中。当Lua试图计算A+B时，它不知道如何添加表，因此检查A的元表中的__add项。如果找到了该条目，Lua将调用存储在那里的函数——将原始操作数A和B作为参数传递。

![图4一个元表的例子。](https://dl.acm.org/cms/attachment/d64e0701-fd18-49f8-943f-ae127e68f198/f4.jpg)

图4一个元表的例子。

索引操作符[]的元方法在Lua中提供了一种委托形式。每当Lua试图从表中检索一个缺席键的值时，就会调用这个名为__index的元方法。(对于userdata, Lua为所有键调用该元方法。)对于索引操作，Lua允许元方法是一个函数或一个表。当___index是一个表时，Lua将对原始表中没有的索引的所有访问委托给该表，如下面的代码片段所示

```lua 
Proto = {x = 0, y = 0}
obj = {x = 10}
mt = {___index = Proto}
setmetatable(obj, mt)
print(obj.x) > 10
print(obj.y) > 0
```

在第二个print调用中，Lua找不到obj中的键“y”，因此委托访问Proto。在第一个输出中，由于obj有一个字段"x"，访问没有委托。

有了表、函数和委托，我们就几乎拥有了基于原型的第二层所需的一切。在它中，程序员也用表或用户数据表示对象。每个对象都可以有一个原型，从中继承方法和字段。对象obj的原型是存储在obj元表__index字段中的对象。然后可以编写obj.foo(x)， Lua将通过委托从对象的原型中检索方法foo。

然而，如果我们就此打住，那么Lua中对面向对象编程的支持可能存在缺陷。在对象的原型中找到并调用该方法之后，该方法将无法访问原对象(即预期的接收者)。Lua通过语法糖解决了这个问题。Lua将“方法”定义翻译为

```lua 
function Proto:foo (x)
    ...
end
```

函数定义:

```lua
function Proto.foo (self, x)
    ...
end
```

同样，Lua将“方法”调用obj:foo(x)转换为obj.foo(obj,x)。当程序员定义一个“方法”时，使用冒号syntaxLua的函数会添加一个隐藏参数self。当程序员使用冒号语法调用“方法”时，Lua提供receiver作为self形参的参数。不需要向语言中添加类、对象或方法，只需添加语法糖即可。

图5说明了这些概念。首先，代码创建了一个原型表Account。然后，代码创建了一个表mt，用作Account实例的元表。然后，它向原型添加了三个方法:一个用于创建实例，一个用于存储，一个用于检索帐户余额。最后，它返回作为该模块结果的原型。

![图5 Lua中简单的基于原型的设计。](https://dl.acm.org/cms/attachment/056c660d-c3c3-4dcf-be5f-8cb44dbd7d5d/f5.jpg)

图5 Lua中简单的基于原型的设计。

假设模块位于文件Account中。在Lua中，下面几行代码执行

```lua
Account = require "Account"
acc = Account:new()
acc:deposit(1000)
print(acc:balance()) -->
1000
```

首先，代码需要模块，然后创建一个帐户;Acc将是一个空表，mt作为它的元表。去糖后，下一行是acc.deposit(acc,1000)。表acc没有存储字段，所以Lua委托访问元表的__index字段中的表。访问的结果就是Account.deposit功能。然后Lua调用该函数，将acc作为第一个参数(self)，将1000作为第二个参数(amount)。在函数内部，Lua将再次委派访问self。Bal到原型机因为acc还没有一个现场Bal。在随后对balance的调用中，Lua将在表acc中找到字段bal并使用该值。因此，不同的账户有不同的余额，但共享所有方法。

在元表的__index中对原型的访问是常规访问，这意味着原型可以被链接。例如，假设程序员将以下代码添加到前面的示例中

```lua
Object = {name = "no name"}
setmetatable(Account,
    { _ _ index = Object})
```

当Lua计算acc.name时，表acc没有名称键，因此Lua尝试在它的原型Account中进行访问。这个表也没有这个键，所以Lua转到Account的原型表Object，在那里它最终找到了一个name字段。

程序员可以通过将余额存储在对象表之外来保持其私有，如图6所示。这个版本和图5的关键区别在于使用了bal[self]而不是self。余额表示账户上的余额。表bal就是我们所说的双表。第二行中对setmetatable的调用导致该表具有弱键，从而允许在程序中没有其他对该帐户的引用时收集该帐户。事实上，bal是模块本地的，确保了该模块之外的代码不能看到或篡改帐户余额，这种技术在需要结构中的私有字段时非常方便。

![图6 具有私有字段的帐户。](https://dl.acm.org/cms/attachment/50b386e3-c4de-4bd5-a504-5c322abba536/f6.jpg)

图6 具有私有字段的帐户。

对Lua对面向对象编程的支持的评估与我们到目前为止讨论的其他机制的评估并没有太大的不同。一方面，Lua中的面向对象特性不像其他为任务提供特定构造的语言那样易于使用。特别是，冒号语法可能会让人有些困惑，主要是针对那些刚接触Lua但对另一种面向对象语言有一些经验的程序员。Lua需要这种语法，因为它的概念很经济，避免在现有的函数概念足够时引入方法概念。

另一方面，Lua中的对象语义简单明了。此外，Lua中对象的实现是灵活的。因为方法选择和变量self是独立的，Lua不需要额外的机制从其他类(比如“super”)调用方法。最后，本设计对C API是友好的。它所需要的只是对表和函数的基本操作，加上标准函数setmetatable。Lua程序员可以用Lua实现原型，用C创建用户数据实例，用C创建原型，用Lua实现方法定义原型，用C实现方法定义原型。所有那些工作实现了无缝连接。

异常处理。Lua中的异常处理是另一种依赖于函数灵活性的机制。一些语言提供了异常处理的try-catch结构;try子句中的代码中的任何异常都会跳转到相应的catch子句。Lua不提供这样的构造，主要是因为C API。

通常情况下，脚本中的异常是由宿主应用程序处理的。try-catch这样的语法构造不容易映射到使用外语的API中。相反，C API将异常处理功能打包到我们在本文前面访问C API时讨论过的高阶函数lua _ pcall(“protected call”)中。函数pcall接收一个函数作为参数并调用该函数。如果所提供的函数在没有错误的情况下终止，pcall返回true;否则，pcall捕获错误并返回false和一个error对象，该对象是引发错误时给出的任何值。无论pcall是如何实现的，它都是在C API中作为常规函数公开的。C API还提供了一个名为lua_ error的函数来引发错误，它的唯一参数是error对象。函数错误也作为常规函数出现在C API中，尽管它永远不会返回。

lua_ pcall和lua_ error都通过标准库反映到lua中。在支持try-catch的语言中，典型的异常处理代码如下所示

```lua
try {
    <<protected code>>
}
catch (errobj) {
    <<exception handling>>
}
```

Lua中的等效代码是这样的

```lua
local ok, errobj = pcall(function ()
    <<protected code>>
end)
if not ok then
    <<exception handling>>
end
```

在这种转换中，具有适当词法范围的匿名函数发挥了核心作用。除了调用转义延续的语句(如break和return)外，其他所有语句都可以在受保护的代码中编写，就像在常规代码中编写一样。

使用pcall进行异常处理有其优缺点，类似于使用模块进行异常处理。一方面，代码可能不像其他支持传统尝试的语言那样优雅。另一方面，它有一个明确的语义。特别是，像“catch子句中的异常发生了什么?”这样的问题有一个明显的答案。此外，它与C API的集成清晰而简单;它是通过常规功能暴露出来的;Lua程序可以在Lua中引发错误，在C中捕获错误，也可以在C中引发错误,在Lua中捕获错误。

## 协同程序

与关联数组和一级函数一样，协程在编程中是一个根深蒂固的概念。然而，不同于表和一级函数，不同的社区实现协程的方式有很大的差异。这些变体中的几个是不相等的，在某种意义上，程序员不能实现一个在另一个之上。

Lua中的协程类似于协作多线程，具有以下区别属性:

一流的值。Lua程序员可以在任何地方创建协程，将它们存储在变量中，将它们作为参数传递，并将它们作为结果返回。更重要的是，他们可以在任何地方恢复协程;

暂停执行。它们可以从嵌套函数中暂停执行。每个协程都有自己的调用栈，其语义类似于协作多线程。当协程产生时，整个栈被保留;

不对称的。对称协程提供了一个单一的控制转移操作，将控制从正在运行的协程转移到另一个给定的协程。另一方面，非对称协程提供了两个控制转移操作，resume和yield，它们像调用-返回对一样工作;

相当于一次连续。尽管存在这种等价性，协程以一种对过程语言来说更自然的格式提供了一次性延续，因为它与多线程相似。

图7展示了Lua中协程的生命周期。程序按此顺序打印10、20、30和40。它首先创建一个协程co，并给出一个匿名函数作为它的主体。该操作只返回新协程的句柄，而不运行它。然后，程序第一次恢复协程，开始执行它的主体。形参x接收给resume的实参，程序打印10。协程然后产生yield，导致调用resume返回值20，这个值是yield的参数。然后程序再次恢复协程，使yield返回为resume指定的值30。然后协程打印30并结束，导致相应的调用恢复返回40，这是协程返回的值。

![图7 这是Lua中协程的一个简单示例。](https://dl.acm.org/cms/attachment/fd49a6f3-f4a0-4f09-b287-bbad313729f4/f7.jpg)

图7 这是Lua中协程的一个简单示例。

协程在Lua中不像表和函数那样广泛使用。然而，在需要的时候，协程扮演着关键的角色，因为它们能够将程序的控制流翻转过来。

协程在Lua中的一个重要用途是实现协作多线程。游戏通常会利用这一功能，因为它们需要控制以保持互动速度的响应。游戏中的每个角色或对象都有自己的脚本，在单独的协程中运行。每个脚本通常都是一个循环，在每次迭代时更新角色的状态，然后产生结果。一个简单的调度程序在每次游戏更新时恢复所有的实时协同程序。

*在模块的情况下，表提供了命名空间，词法作用域提供了封装，一级函数允许函数导出。*

协程的另一个用途是解决“谁是老板”的问题。脚本语言的一个典型问题是决定是嵌入还是扩展。当程序员嵌入脚本语言时，宿主是老大，也就是说，用外语编写的宿主程序具有程序的主循环，并为特定任务调用用脚本语言编写的函数。当程序员扩展脚本语言时，脚本就是老大;然后程序员用外语为它编写库，程序的主循环在脚本中。

嵌入和扩展都有优点和缺点，Lua-C API同样支持它们。然而，外部代码可能就不那么容易原谅了。假设一个大型的单片应用程序包含特定脚本的一些有用功能。程序员希望将脚本编写为boss，从外部应用程序调用函数。然而，应用程序本身假定它是老板。此外，将应用程序分解成单独的函数，并将它们作为一个一致的库提供给脚本可能会很困难。

协程提供了一种更简单的设计。程序员修改应用程序，以便在它启动时用脚本创建一个协程;每当应用程序需要一个输入时，它就恢复那个协程。这是程序员需要在应用程序中进行的惟一更改。就脚本本身而言，它看起来也像一个常规的程序，除了在需要向应用程序发送命令时产生生成。结果程序的控制流程如下所示:应用程序启动，创建协程，进行自己的初始化，然后通过恢复协程等待输入。然后协程开始运行，进行自己的初始化，并执行其职责，直到需要应用程序的某些服务为止。此时，脚本生成一个请求，应用程序返回恢复调用，应用程序为给定请求提供服务。然后，应用程序通过再次恢复脚本来等待下一个请求。

在C API中表示协程显然比表示函数和表更具挑战性。C代码可以毫无限制地创建和恢复协程。特别是，恢复工作类似于常规的函数调用:它(重新)在调用时激活给定的协程，并在协程产生或结束时返回。然而，屈服也带来了一个问题。一旦C函数产生了问题，以后就没有办法将控制权返回到函数中的那个点。API提供了两种方法来绕过这个限制:第一种是在尾部位置屈服:当协程恢复时，它直接转到调用Lua函数。第二种方法是在屈服时提供一个延续函数。这样，当协程恢复时，控制转到continuation函数，该函数可以完成原函数的任务。

在API中，我们再次看到了像Lua这样的语言的非对称协程的优势。对于对称协程，所有的传输都有非对称协程只有在屈服时才会有的问题。根据我们的经验，来自C的恢复比屈服更常见。

## 结论

每个设计都涉及平衡相互冲突的目标。为了解决这些冲突，设计师需要优先考虑他们的目标。这显然适用于任何编程语言的设计。

Lua有一组独特的设计目标，优先考虑简单性、可移植性和嵌入性。Lua核心基于三个众所周知的、经过验证的概念:关联数组、一级函数和协程，这些都是在没有人为限制的情况下实现的。在这些组件之上，Lua遵循“机制而不是策略”的座右铭，这意味着Lua的设计旨在提供基本机制，允许程序员实现更复杂的功能。例如，在模块的情况下，表提供了命名空间，词法作用域提供了封装，一级函数允许函数导出。在此基础上，Lua只添加了搜索和加载模块所需的函数。

模块化在语言设计中并不是什么新鲜事例如，它可用于阐明大型构造的应用然而，Lua使用模块化来保持其小尺寸，将复杂的结构分解为现有的机制。

“机制而非政策”的口号也使语言变得灵活，有时过于灵活。例如，类和对象的diy方法会导致不同的、通常不兼容的系统的扩散，但当程序员需要使Lua适应宿主程序的类模型时，这种方法很方便。

Lua中使用的表、函数和协程多年来显示出了很大的灵活性。尽管语言在不断发展，但程序员很少要求改变基本机制。

由于缺乏内置的复杂结构和最低限度的标准库(用于可移植性和小尺寸)，Lua在编写“快速而肮脏”的程序方面不如其他脚本语言。Lua中的许多程序都需要程序员在初始阶段建立这种语言，作为面向对象编程的最小基础设施。Lua通常嵌入到宿主应用程序中。嵌入需要规划，语言的设置通常与它的嵌入相集成。Lua的概念经济要求程序员更深入地理解他们在做什么，因为大多数构造在代码中都是明确的。这种明确性也允许更深层次的理解。我们相信这是一种祝福，而不是诅咒。


